-- Script 1: cautious-banner-grab.nse
-- Ultra-quiet banner grabbing with minimal footprint

local stdnse = require "stdnse"
local shortport = require "shortport"
local nmap = require "nmap"
local string = require "string"

description = [[
Performs very cautious banner grabbing with extended delays and minimal probes.
Uses natural timing patterns to avoid detection.
]]

author = "-pk"
license = "Same as Nmap--See https://nmap.org/book/man-legal.html"
categories = {"safe", "discovery", "version"}

portrule = shortport.port_or_service({21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995}, 
  {"ftp", "ssh", "telnet", "smtp", "http", "https", "pop3", "imap"})

action = function(host, port)
  local result = {}
  local socket = nmap.new_socket()
  
  -- Very steep timeout
  socket:set_timeout(30000)
  
  local status, err = socket:connect(host, port)
  if not status then
    socket:close()
    return nil
  end
  
  -- Wait longer before any activity
  stdnse.sleep(math.random(2, 5))
  
  -- Try to receive banner without sending anything first
  local banner_status, banner = socket:receive_lines(1)
  if banner_status and banner and banner ~= "" then
    result.banner = banner
  end
  
  -- For HTTP, send minimal request
  if port.number == 80 or port.number == 443 then
    stdnse.sleep(math.random(1, 3))
    socket:send("HEAD / HTTP/1.0\r\n\r\n")
    stdnse.sleep(1)
    local http_status, http_resp = socket:receive()
    if http_status and http_resp then
      local server_header = string.match(http_resp, "[Ss]erver: ([^\r\n]*)")
      if server_header then
        result.http_server = server_header
      end
    end
  end
  
  socket:close()
  
  if next(result) then
    return result
  else
    return nil
  end
end

-----------------------------------------------------------

-- Script 2: cautious-os-detect.nse
-- Passive OS detection through subtle timing analysis

local stdnse = require "stdnse"
local shortport = require "shortport"
local nmap = require "nmap"
local string = require "string"
local math = require "math"

description = [[
Performs cautious OS detection using passive timing analysis and minimal probes.
Avoids aggressive fingerprinting techniques.
]]

author = "Custom Security Script"
license = "Same as Nmap--See https://nmap.org/book/man-legal.html"
categories = {"safe", "discovery", "intrusive"}

portrule = shortport.port_or_service({22, 80, 443})

action = function(host, port)
  local results = {}
  local timings = {}
  
  -- Perform multiple connection attempts with timing analysis
  for i = 1, 3 do
    local socket = nmap.new_socket()
    socket:set_timeout(10000)
    
    local start_time = stdnse.clock_ms()
    local status, err = socket:connect(host, port)
    local connect_time = stdnse.clock_ms() - start_time
    
    if status then
      table.insert(timings, connect_time)
      
      -- Small delay between attempts
      stdnse.sleep(math.random(5, 10))
      
      -- Send minimal probe and measure response time
      local probe_start = stdnse.clock_ms()
      if port.number == 22 then
        socket:send("SSH-2.0-OpenSSH_Test\r\n")
      elseif port.number == 80 then
        socket:send("HEAD / HTTP/1.0\r\n\r\n")
      end
      
      local response_status, response = socket:receive_lines(1)
      local response_time = stdnse.clock_ms() - probe_start
      
      if response_status and response then
        results.response_pattern = string.sub(response or "", 1, 50)
        results.avg_response_time = response_time
      end
    end
    
    socket:close()
    
    -- Long delay between connection attempts
    if i < 3 then
      stdnse.sleep(math.random(15, 30))
    end
  end
  
  -- Analyze timing patterns (very basic heuristics)
  if #timings >= 2 then
    local avg_timing = 0
    for _, time in ipairs(timings) do
      avg_timing = avg_timing + time
    end
    avg_timing = avg_timing / #timings
    
    results.avg_connect_time = string.format("%.2f ms", avg_timing)
    
    -- Basic OS hints based on timing (very rough estimates)
    if avg_timing < 50 then
      results.os_hint = "Possibly Linux/Unix (fast response)"
    elseif avg_timing > 200 then
      results.os_hint = "Possibly Windows (slower response)"
    else
      results.os_hint = "Unknown (moderate response time)"
    end
  end
  
  if next(results) then
    return results
  else
    return nil
  end
end

-----------------------------------------------------------

-- Script 3: cautious-service-probe.nse
-- Minimal service detection with natural request patterns

local stdnse = require "stdnse"
local shortport = require "shortport"
local nmap = require "nmap"
local string = require "string"
local math = require "math"

description = [[
Performs cautious service detection using minimal, natural-looking probes.
Designed to blend in with normal network traffic.
]]

author = "-pk"
license = "Same as Nmap--See https://nmap.org/book/man-legal.html"
categories = {"safe", "discovery", "version"}

portrule = shortport.open

action = function(host, port)
  local socket = nmap.new_socket()
  local results = {}
  
  socket:set_timeout(20000)
  
  local status, err = socket:connect(host, port)
  if not status then
    socket:close()
    return nil
  end
  
  -- Wait to mimic human behavior
  stdnse.sleep(math.random(3, 8))
  
  -- Port-specific minimal probes
  local probe_sent = false
  
  if port.number == 80 or port.number == 8080 then
    socket:send("GET / HTTP/1.1\r\nHost: " .. host.ip .. "\r\nUser-Agent: Mozilla/5.0\r\n\r\n")
    probe_sent = true
  elseif port.number == 443 or port.number == 8443 then
    -- For HTTPS, just try to get initial handshake
    results.service = "https"
    probe_sent = false
  elseif port.number == 21 then
    -- FTP - wait for banner
    probe_sent = false
  elseif port.number == 22 then
    socket:send("SSH-2.0-OpenSSH_7.4\r\n")
    probe_sent = true
  elseif port.number == 25 then
    socket:send("EHLO test.local\r\n")
    probe_sent = true
  elseif port.number == 53 then
    results.service = "dns"
    probe_sent = false
  else
    -- Generic probe for unknown services
    socket:send("\r\n")
    probe_sent = true
  end
  
  -- Wait for response
  stdnse.sleep(2)
  
  local response_status, response = socket:receive()
  if response_status and response and response ~= "" then
    -- Extract service information carefully
    local response_lower = string.lower(response)
    
    if string.match(response_lower, "http/") then
      results.service = "http"
      local server = string.match(response, "[Ss]erver: ([^\r\n]*)")
      if server then
        results.server = server
      end
    elseif string.match(response_lower, "ssh") then
      results.service = "ssh"
      local version = string.match(response, "SSH%-([^\r\n]*)")
      if version then
        results.version = version
      end
    elseif string.match(response_lower, "ftp") then
      results.service = "ftp"
    elseif string.match(response_lower, "smtp") then
      results.service = "smtp"
    elseif string.match(response_lower, "pop3") then
      results.service = "pop3"
    elseif string.match(response_lower, "imap") then
      results.service = "imap"
    else
      -- Try to identify by response patterns
      if string.len(response) > 0 then
        results.service = "unknown"
        results.response_sample = string.sub(response, 1, 100)
      end
    end
  end
  
  socket:close()
  
  if next(results) then
    return results
  else
    return nil
  end
end

-----------------------------------------------------------

-- Script 4: cautious-vuln-check.nse
-- Very conservative vulnerability checking

local stdnse = require "stdnse"
local shortport = require "shortport"
local nmap = require "nmap"
local http = require "http"
local string = require "string"
local math = require "math"

description = [[
Performs very cautious vulnerability checks using passive detection methods.
Only checks for obvious misconfigurations without active exploitation.
]]

author = "Custom Security Script"
license = "Same as Nmap--See https://nmap.org/book/man-legal.html"
categories = {"safe", "vuln"}

portrule = shortport.port_or_service({21, 22, 23, 80, 443, 2121, 8080})

action = function(host, port)
  local results = {}
  local vulnerabilities = {}
  
  if port.number == 21 then
    -- Check for anonymous FTP
    local socket = nmap.new_socket()
    socket:set_timeout(15000)
    
    local status = socket:connect(host, port)
    if status then
      stdnse.sleep(2)
      local banner_status, banner = socket:receive_lines(1)
      
      if banner_status and banner then
        stdnse.sleep(1)
        socket:send("USER anonymous\r\n")
        stdnse.sleep(1)
        local user_status, user_resp = socket:receive_lines(1)
        
        if user_status and user_resp and string.match(user_resp, "230") then
          table.insert(vulnerabilities, "Anonymous FTP access allowed")
        end
      end
      socket:close()
    end
    
  elseif port.number == 80 or port.number == 8080 then
    -- Check for common misconfigurations
    stdnse.sleep(math.random(2, 5))
    
    local response = http.get(host, port, "/")
    if response and response.status == 200 and response.body then
      local body_lower = string.lower(response.body)
      
      -- Check for directory listing
      if string.match(body_lower, "index of") or string.match(body_lower, "directory listing") then
        table.insert(vulnerabilities, "Directory listing enabled")
      end
      
      -- Check for server information disclosure
      if response.header and response.header.server then
        if string.match(response.header.server, "%d+%.%d+") then
          table.insert(vulnerabilities, "Server version disclosure: " .. response.header.server)
        end
      end
    end
    
    -- Check for common sensitive files (very carefully)
    local sensitive_files = {"/robots.txt", "/.htaccess"}
    for _, file in ipairs(sensitive_files) do
      stdnse.sleep(math.random(3, 8))
      local file_resp = http.get(host, port, file)
      if file_resp and file_resp.status == 200 then
        table.insert(vulnerabilities, "Sensitive file accessible: " .. file)
      end
    end
  
  elseif port.number == 22 then
    -- SSH version check
    local socket = nmap.new_socket()
    socket:set_timeout(10000)
    
    local status = socket:connect(host, port)
    if status then
      stdnse.sleep(1)
      local banner_status, banner = socket:receive_lines(1)
      
      if banner_status and banner then
        -- Check for old SSH versions (very conservative)
        if string.match(banner, "SSH%-1%.") then
          table.insert(vulnerabilities, "Old SSH protocol version 1.x detected")
        elseif string.match(banner, "OpenSSH_[1-5]%.") then
          table.insert(vulnerabilities, "Potentially outdated SSH version")
        end
      end
      socket:close()
    end
  end
  
  if #vulnerabilities > 0 then
    results.potential_issues = vulnerabilities
    results.note = "These are passive observations only. Further investigation recommended."
  end
  
  if next(results) then
    return results
  else
    return nil
  end
end

-----------------------------------------------------------
-- Usage Examples:

-- To use these scripts:
-- 1. Save each script to a .nse file (e.g., cautious-banner-grab.nse)
-- 2. Place in Nmap's scripts directory or specify path
-- 3. Run with: nmap --script cautious-banner-grab target
-- 4. For maximum stealth, combine with: -T1 -sS -f --scan-delay 10s

-- Example command for ultra-cautious scan:
-- nmap -T1 -sS -f --scan-delay 15s --max-retries 1 --script cautious-banner-grab,cautious-service-probe target.com
